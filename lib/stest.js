var events = require("events"),
	fs = require("fs"),
	path = require("path"),
	color = require("colors"),
	coverage = null;

/*
 * @class stest
 *
 * A simple async testing class.
 *
 * @api public
 */

function stest(){

	var self = this;

	this.ctx = {};
	this.promise = new events.EventEmitter();
	this._queue = [];

	this._coverqueue = [];

	this._out = function(col, str){
		if(!str)
			process.stdout.write(col);
		else
			process.stdout.write(color[col](str));
	}

	this._addTime = function(func){
		var now = Date.now();
		func();
		return Date.now() - now;
	}

	this._report = function(name, errors, time){

		var result = "",
			c = "green";

		if(!errors.length)
			// check
			result = "\u2713";
		else{
			// cross
			result = "\u2717";
			c = "red";
		}

		// write results
		self._out(c, result+" "+name+" - "+time+"ms\n");
		// print errs
		errors.forEach(function(err){
			self._out("red", err.message+"\n");
			if(err.type !== "stest")
				self._out("red", err.stack+"\n");
		});
	}

    this._reportCoverage = function(){
        if(!coverage) coverage = function(){};

        // show coverage data
	    coverage(function(cd){
		    self._coverqueue.forEach(function(lib){
			    var file = fs.readFileSync(lib).toString().split("\n");
			    var stats = cd[lib].stats();
			    var c = "magenta", err = "red", g = "green";

			    self._out("\n");
			    self._out(c, "Module: "+path.basename(lib)+"\n");
			    self._out(c, "Percentage seen: "+Math.floor(stats.percentage*100)+"%\n");
			    self._out(c, "Lines seen: "+stats.seen+"\n");
			    self._out(c, "Lines missed: "+stats.missing+"\n");

                // this keeps track of the difference of lines between errors
                // so that errors can be grouped according to proximity
                var chainDiff = 0;
			    stats.lines.forEach(function(line, i, lines){
                    var lnum = line.lineno,
                        diff = lnum - chainDiff;

                    // if there's only a small gap between the lines,
                    // write the lines in between, or we have a break
                    if(diff < 10){
                        for(var t = 1; t < diff; t++){
                            var inv = diff - t;
                            self._out(g, (lnum-inv)+": "+file[(lnum-1)-inv]+"\n");
                        }
                    }else{
                        // if we aren't at the start, write the lines preceding
                        // the last break
                        if(chainDiff !== 0){
                            for(var e = 1; e < 5; e++)
                                self._out(g, (chainDiff+e)+": "+file[(chainDiff+e)-1]+"\n");
                        }

                        self._out("\n");

                        // write the lines before this new break
                        for(var q = 1; q < 5; q++){
                            var qdiff = 5 - q;
                            self._out(g, (lnum-qdiff)+": "+file[(lnum-1)-qdiff]+"\n");
                        }
                    }

                    self._out(err, lnum+": "+line.source()+"\n");
                    chainDiff = lnum;
			    });

                if(chainDiff !== 0){
                    for(var p = 1; p < 5; p++)
                        self._out(g, (chainDiff+p)+": "+file[(chainDiff-1)+p]+"\n");
                }
		    });
		    coverage.release();

            self._out("\n");
	    });
    }
}

/*
 * Adds a test cass to stest, along with some
 * other acnillary stuff.
 *
 * @param {String} name
 * @param {Object} opts
 * @param {Object} test
 *
 * The name will be displayed upon output.
 *
 * The opts object looks like this:
 *
 * var opts = { timeout: 1000 }
 *
 * After the number of miliseconds specified by
 * the timeout parameter, stest will throw an
 * error. If you provide 0, or do not provide a
 * timeout value, the default timeout is 250
 * miliseconds.
 *
 * The test object looks something like this:
 *
 *	{
 * 		setup: function(promise){
 *			// emit events
 *			promise.emit("event_1", 42);
 * 		},
 * 		event_1: function(num){
 *			// catch events
 *			assert.deepEqual(42, num);
 * 		},
 * 		teardown: function(errors){
 *			// (optional)
 *			// the errors object can
 *			// be modified if you intend to
 *			// create errors
 * 		}
 *	}
 *
 * The setup key is required, all other keys and
 * functions are optional. Errors in the teardown
 * function have two extra properties; an event
 * property indicating the event that wasn't fired,
 * and a type, indicating weather the error was
 * generated by stest or not. stest errors have a
 * type equal to "stest". For example:
 *
 * teardown: function(errors){
 * 		// created two intentional errors earlier
 * 		if (errors.length > 2) assert.ok(0);
 * }
 *
 * This method can also be chained to include
 * multiple cases, like so:
 *
 * stest.addCase(...,{
 *	...
 * })
 * .addCase(..., {
 *	...
 * }).run();
 *
 * @api public
 */

stest.prototype.addCase = function(name, opts, test){

	this._queue.push({ name: name, opts: opts, test: test });
	return this;
}

/*
 * Allows stest to track function calls for
 * code coverage
 *
 * @param {String} lib
 *
 * This method returns the same object as
 * require(lib) except it allows stest to track
 * which functions have been called and which
 * haven't.
 *
 * @api public
 */

stest.prototype.cover = function(lib){

    if(!coverage) coverage = require("runforcover").cover(/.*/);

	var realroot = path.dirname(module.parent.filename);
	lib = path.resolve(realroot, lib);
    if(path.extname(lib) == "") lib += ".js"

	this._coverqueue.push(lib);

	return require(lib);
}

/*
 * Runs the test cases synchronously
 *
 * @param {Function} callback
 *
 * All output is written to stdout.
 *
 * The callback is called after all of the
 * tests in the suite have been run and
 * their timeouts have expired. Note that
 * this is not a place to keep teardown
 * code, the teardown method is more
 * appropriate.
 *
 * @api public
 */

stest.prototype.run = function(callback){

	// clear context
	this.ctx = {};
	var self = this,
        timeoutsComplete = 0;

    this._queue.forEach(function(tcase){
        var test = tcase.test,
            opts = tcase.opts,
            name = tcase.name;

		var setup = test.setup;
		var teardown = test.teardown || function(){};

		if(!setup) throw new Error("A setup method is required");

		// to record elapsed time
		var totalTime = 0;
		// to record error
		var errors = [];

		// delete the setup and teardown keys
		delete test.setup;
		if(test.teardown) delete test.teardown;

		// add listeners for each key
		Object.keys(test).forEach(function(event, i, array){
			self.promise.once(event, function(){
				var args = Array.prototype.slice.call(arguments, 0);
				totalTime += self._addTime(function(){
					try{
						test[event].apply(self.ctx, args);
					}catch(e){
						e.event = "event";
						errors.push(e);
					}
				});
			});
		});

		// user setup
		totalTime += self._addTime(function(){ setup.apply(self.ctx,[self.promise]); });

		// start the timeout
		setTimeout(function(){

			// makes sure everything is removed
			Object.keys(test).forEach(function(event){
				var ears = self.promise.listeners(event).length;
				if(ears > 0){
					var e = new Error("The '"+event+"' event never fired.");
					e.type = "stest";
					e.event = event;
					errors.push(e);
					self.promise.removeAllListeners(event);
				}
			});

			// user teardown
			totalTime += self._addTime(function(){ teardown.apply(self.ctx,[errors]); });
			//give a report
			self._report(name, errors, totalTime);

            timeoutsComplete++;
            if(timeoutsComplete === self._queue.length){
                self._reportCoverage();
                if(callback) callback();
            }

		}, (opts.timeout > 0 ? opts.timeout : 250));
	});

}

/*
 * Runs only the coverage
 *
 * All output is written to stdout.
 *
 * This may be called many times,
 * without an consequences.
 *
 * @api public
 */

stest.prototype.runCoverage = function(){
    this._reportCoverage();

    return this;
}

// Exports
module.exports = new stest();
