var events = require("events"),
	fs = require("fs"),
	path = require("path"),
	color = require("colors"),
	coverage = require("runforcover").cover(/.*/);

/*
 * @class stest
 *
 * A simple async testing class.
 *
 * @api public
 */

function stest(){

	var self = this;

	this.ctx = {};
	this.promise = new events.EventEmitter();
	this._queue = [];

	this._coverqueue = [];

	this._out = function(col, str){
		if(!str)
			process.stdout.write(col);
		else
			process.stdout.write(color[col](str));
	}

	this._addTime = function(func){
		var now = Date.now();
		func();
		return Date.now() - now;
	}

	this._report = function(name, errors, time){
		
		var result = "",
			c = "green";

		if(!errors.length)
			// check
			result = "\u2713";
		else{
			// cross
			result = "\u2717";
			c = "red";
		}

		// write results
		self._out(c, result+" "+name+" - "+time+"ms\n");
		// print errs
		errors.forEach(function(err){
			self._out("red", err.message+"\n");
			if(err.type !== "stest")	
				self._out("red", err.stack+"\n");
		});
	}
}

/*
 * Adds a test cass to stest, along with some 
 * other acnillary stuff.
 *
 * @param {String} name 
 * @param {Object} opts
 * @param {Object} test
 *
 * The name will be displayed upon output.
 *
 * The opts object looks like this:
 *
 * var opts = { timeout: 1000 } 
 *
 * After the number of miliseconds specified by
 * the timeout parameter, stest will throw an
 * error. If you provide 0, or do not provide a
 * timeout value, the default timeout is 250
 * miliseconds.
 *
 * The test object looks something like this:
 *
 *	{ 
 * 		setup: function(promise){
 *			// emit events
 *			promise.emit("event_1", 42);
 * 		},
 * 		event_1: function(num){
 *			// catch events
 *			assert.deepEqual(42, num); 
 * 		},
 * 		teardown: function(errors){
 *			// (optional)
 *			// the errors object can 
 *			// be modified if you intend to 
 *			// create errors
 * 		}
 *	}
 *
 * The setup key is required, all other keys and
 * functions are optional. Errors in the teardown
 * function have two extra properties; an event
 * property indicating the event that wasn't fired, 
 * and a type, indicating weather the error was 
 * generated by stest or not. stest errors have a 
 * type equal to "stest". For example:
 *
 * teardown: function(errors){
 * 		// created two intentional errors earlier
 * 		if (errors.length > 2) assert.ok(0);
 * }
 *
 * This method can also be chained to include 
 * multiple cases, like so:
 *
 * stest.addCase(...,{
 *	...
 * })
 * .addCase(..., {
 *	...
 * }).run();
 *
 * @api public
 */

stest.prototype.addCase = function(name, opts, test){

	this._queue.push({ name: name, opts: opts, test: test });
	return this;
}

/*
 * Allows stest to track function calls for 
 * code coverage
 *
 * @param {String} lib
 *
 * This method returns the same object as
 * require(lib) except it allows stest to track
 * which functions have been called and which 
 * haven't. 
 *
 * @api public
 */


stest.prototype.cover = function(lib){

	var realroot = path.dirname(module.parent.filename);
	lib = path.resolve(realroot, lib);
	this._coverqueue.push(lib);
	
	return require(lib);
}

/*
 * Runs the test cases synchronously
 *
 * All output is written to stdout.
 *
 * @api public
 */

stest.prototype.run = function(){

	// clear context
	this.ctx = {};
	var self = this;

	this._queue.forEach(function(tcase){
		
		var test = tcase.test;
		var opts = tcase.opts;
		var name = tcase.name;

		var setup = test.setup;
		var teardown = test.teardown || function(){};
		
		if(!setup) throw new Error("A setup method is required");
		
		// to record elapsed time
		var totalTime = 0;
		// to record error
		var errors = [];

		// delete the setup and teardown keys
		delete test.setup;
		if(test.teardown) delete test.teardown;

		// add listeners for each key
		Object.keys(test).forEach(function(event, i, array){
			self.promise.once(event, function(){
				var args = Array.prototype.slice.call(arguments, 0);
				totalTime += self._addTime(function(){	
					try{
						test[event].apply(self.ctx, args);
					}catch(e){
						e.event = "event";
						errors.push(e);
					}
				});
			});
		});

		// user setup
		totalTime += self._addTime(function(){ setup.apply(self.ctx,[self.promise]); });

		// start the timeout
		setTimeout(function(){

			// makes sure everything is removed
			Object.keys(test).forEach(function(event){
				var ears = self.promise.listeners(event).length;
				if(ears > 0){
					var e = new Error("The '"+event+"' event never fired.");
					e.type = "stest";
					e.event = event;
					errors.push(e);
					self.promise.removeAllListeners(event);
				}
			});
			
			// user teardown
			totalTime += self._addTime(function(){ teardown.apply(self.ctx,[errors]); });
			//give a report
			self._report(name, errors, totalTime);
		
			coverage(function(cd){	
				self._coverqueue.forEach(function(lib){
					var file = fs.readFileSync(lib).toString().split("\n");
					var stats = cd[lib].stats();
					var c = "magenta", err = "red", g = "green";

					self._out("\n");
					self._out(c, "Module: "+path.basename(lib)+"\n");
					self._out(c, "Percentage seen: "+Math.floor(stats.percentage*100)+"%\n");
					self._out(c, "Lines seen: "+stats.seen+"\n");
					self._out(c, "Lines missed: "+stats.missing+"\n");
			
					stats.lines.forEach(function(line){
						self._out("\n");
						self._out(g, line.lineno-1+": "+file[line.lineno-2]+"\n");
						self._out(err, line.lineno+": "+line.source()+"\n");
						self._out(g, line.lineno+1+": "+file[line.lineno]+"\n");
					});
			
					self._out("\n");
				});		
				coverage.release();
			});
		}, (opts.timeout > 0 ? opts.timeout : 250));
	});
}

// Exports
module.exports = new stest();
