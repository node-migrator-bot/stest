var events = require("events"),
	color = require("colors");

/*
 * @class stest
 *
 * A simple async testing class.
 *
 * @api public
 */

function stest(){

	var self = this;

	this.ctx = {};
	this.promise = new events.EventEmitter();
	this._queue = [];

	this._addTime = function(func){
		var now = Date.now();
		func();
		return Date.now() - now;
	}

	this._report = function(name, errors, time){
		
		var result = "",
			c = "green";

		if(!errors.length)
			// check
			result = "\u2713";
		else{
			// cross
			result = "\u2717";
			c = "red";
		}

		// write results
		process.stdout.write(color[c](result+" "+name+" - "+time+"ms\n"));
		// print errs
		errors.forEach(function(err){
			process.stdout.write(color.red(err.message+"\n"));
			if(err.type !== "stest")	
				process.stdout.write(color.red(err.stack+"\n"));
		});
	}
}

/*
 * Adds a test cass to stest, along with some 
 * other acnillary stuff.
 *
 * @param {String} name 
 * @param {Object} opts
 * @param {Object} test
 *
 * The name will be displayed upon output.
 *
 * The opts object looks like this:
 *
 * var opts = { timeout: 1000 } 
 *
 * After the number of miliseconds specified by
 * the timeout parameter, stest will throw an
 * error. If you provide 0, or do not provide a
 * timeout value, the default timeout is 250
 * miliseconds.
 *
 * The test object looks something like this:
 *
 *	{ 
 * 		setup: function(promise){
 *			// emit events
 *			promise.emit("event_1", 42);
 * 		},
 * 		event_1: function(num){
 *			// catch events
 *			assert.deepEqual(42, num); 
 * 		},
 * 		teardown: function(errors){
 *			// (optional)
 *			// the errors object can 
 *			// be modified if you intend to 
 *			// create errors
 * 		}
 *	}
 *
 * The setup key is required, all other keys and
 * functions are optional. Errors in the teardown
 * function have two extra properties; an event
 * property indicating the event that wasn't fired, 
 * and a type, indicating weather the error was 
 * generated by stest or not. stest errors have a 
 * type equal to "stest". For example:
 *
 * teardown: function(errors){
 * 		// created two intentional errors earlier
 * 		if (errors.length > 2) assert.ok(0);
 * }
 *
 * This method can also be chained to include 
 * multiple cases, like so:
 *
 * stest.addCase(...,{
 *	...
 * })
 * .addCase(..., {
 *	...
 * }).run();
 *
 * @api public
 */

stest.prototype.addCase = function(name, opts, test){

	this._queue.push({ name: name, opts: opts, test: test });
	return this;
}

/*
 * Runs the test cases synchronously
 *
 * All output is written to stdout.
 *
 * @api public
 */

stest.prototype.run = function(){

	// clear context
	this.ctx = {};
	var self = this;

	this._queue.forEach(function(tcase){
		
		var test = tcase.test;
		var opts = tcase.opts;
		var name = tcase.name;

		var setup = test.setup;
		var teardown = test.teardown || function(){};
		
		if(!setup) throw new Error("A setup method is required");
		
		// to record elapsed time
		var totalTime = 0;
		// to record error
		var errors = [];

		// delete the setup and teardown keys
		delete test.setup;
		if(test.teardown) delete test.teardown;

		// add listeners for each key
		Object.keys(test).forEach(function(event, i, array){
			self.promise.once(event, function(){
				var args = Array.prototype.slice.call(arguments, 0);
				totalTime += self._addTime(function(){	
					try{
						test[event].apply(self.ctx, args);
					}catch(e){
						e.event = "event";
						errors.push(e);
					}
				});
			});
		});

		// user setup
		totalTime += self._addTime(function(){ setup.apply(self.ctx,[self.promise]); });

		// start the timeout
		setTimeout(function(){

			// makes sure everything is removed
			Object.keys(test).forEach(function(event){
				var ears = self.promise.listeners(event).length;
				if(ears > 0){
					var e = new Error("The '"+event+"' event never fired.");
					e.type = "stest";
					e.event = event;
					errors.push(e);
					self.promise.removeAllListeners(event);
				}
			});
			
			// user teardown
			totalTime += self._addTime(function(){ teardown.apply(self.ctx,[errors]); });
			//give a report
			self._report(name, errors, totalTime);
		}, (opts.timeout > 0 ? opts.timeout : 250));
	});
}

// Exports
module.exports = new stest();
